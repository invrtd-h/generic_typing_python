a, b = input(), input()
memo = [[-1 for _ in range  (
    0, 100
) ] for _ in range(100)]
def dp(i: int, j: int):
    if i < 0 or j < 0:
        return 0
    if memo[i][j] != -1:
        return memo[i][j]
testify = (1, 2, (3,
           4), 5,
           6, ")(()")

 # test comment 1
test_str = "#test_comment"

n, s = int(input()), input() # test comment 2
M, m, now = 0, 0, 0
for c in s:
    now += 1 if c == '(' else -1
    M, m = max([M, now]), min([m, now])
print(max([M, -m]) if not now else -1)

a = (
    3 # test comment 3
)

from functools import cache

import sys
sys.setrecursionlimit(10000)

@cache
def dp(n: int):
    if n <= 3:
        return [False, True, False, True][n]
    return (not dp(n - 1)) or (not dp(n - 3))

print("SK" if dp(int(input())) else "CY")

from typing import Optional
from functools import reduce


class ProgramLine:
    __slots__ = ("data", "initial_indents", "indent_policy")

    def __init__(self, raw_line: str) -> None:
        i: int = 0
        while i < len(raw_line) and (raw_line[i] == " " or raw_line[i] == '\t'):
            i += 1

        if raw_line[:i].count(' ') != i and raw_line[:i].count('\t') != i:
            raise ValueError("Indentation must be either all spaces or all tabs")

        self.initial_indents: int = i
        self.data: str = raw_line[i:]

        self.indent_policy: Optional[str] = None
        if not raw_line:
            pass
        elif raw_line[0] == ' ':
            self.indent_policy = ' '
        elif raw_line[0] == '\t':
            self.indent_policy = '\t'

    def __bool__(self) -> bool:
        return bool(self.data)


class Program:
    __slots__ = ("lines", "indent_type")

    def __init__(self, raw_program: str) -> None:
        splitted_data: list[str] = Program._nlparse(raw_program)
        self.lines: list[ProgramLine] = [ProgramLine(line) for line in splitted_data]

        # determine indent type of program
        self.indent_type: Optional[str] = None

        for p_line in self.lines:
            if p_line.indent_policy is not None:
                if self.indent_type is None:
                    self.indent_type = p_line.indent_policy
                elif self.indent_type != p_line.indent_policy:
                    raise ValueError("Indentation must be either all spaces or all tabs")

        self._add_semicolon()
        self._add_parentheses()

    def __repr__(self) -> str:
        """Returns the program as a string"""
        temp = map(self.line_to_str, self.lines)
        return reduce(lambda x, y: x + "\n" + y, temp)

    def line_to_str(self, line: ProgramLine) -> str:
        """Returns a ProgramLine as a string"""
        if self.indent_type is None:
            return line.data
        return self.indent_type * line.initial_indents + line.data

    @staticmethod
    def _nlparse(s: str) -> list[str]:
        ret = ["PROGRAM BEGIN", ""]
        stack = []

        for c in s:
            if not stack and c == '\n':
                ret.append("")
            if c != '\n':
                ret[-1] += c

            if stack:
                if stack[-1] == '"' and c != '"':
                    continue
                if stack[-1] == "'" and c != "'":
                    continue

            if c in {'(', '[', '{'}:
                stack.append(c)
            elif c in {'"', "'"} and (not stack or stack[-1] not in {'"', "'"}):
                stack.append(c)
            elif c == ')':
                if stack and stack[-1] == '(':
                    stack.pop()
                else:
                    raise Exception('Unbalanced parentheses')
            elif c == ']':
                if stack and stack[-1] == '[':
                    stack.pop()
                else:
                    raise Exception('Unbalanced parentheses')
            elif c == '}':
                if stack and stack[-1] == '{':
                    stack.pop()
                else:
                    raise Exception('Unbalanced parentheses')
            elif c == '"':
                if stack and stack[-1] == '"':
                    stack.pop()
                else:
                    raise Exception('Unbalanced parentheses')
            elif c == '\'':
                if stack and stack[-1] == '\'':
                    stack.pop()
                else:
                    raise Exception('Unbalanced parentheses')

        ret.append("PROGRAM END")
        return ret

    def _add_semicolon(self) -> None:
        for line in self.lines:
            if line and line.data[-1] not in ';:':
                line.data += ';'
        return None

    def _add_parentheses(self) -> None:
        stack: list[ProgramLine] = []

        for line in self.lines:
            if not line:
                continue

            while stack and line.initial_indents <= stack[-1].initial_indents:
                line.data = '}' + line.data
                stack.pop()

            if line.data[-1] == ';':
                continue
            if line.data[-1] == ':':
                if stack and line.initial_indents < stack[-1].initial_indents:
                    raise ValueError("Unexpected Indentation")
                line.data += '{'
                stack.append(line)


if __name__ == '__main__':
    f = open("../input.txt", 'r')
    s = f.read()
    f.close()

    result = Program(s)
    print(result)

# 1. trait definition
# the following trait definition says that
# typename 'Self' should support .append(x) and .pop() operation
# and __len__ method

trait StackLike(Self):
    declare_fn:
        append(Self, any) -> [Self or None]
        pop(Self) -> [Self or None]

    declare_fn:
        __len__(Self) -> int


# the following trait definition says that
# the instance of the class 'Self' should have 'x', 'y' member variables

trait PointLike(Self):
    declare:
        x: int
        y: int


# 2. traits with 2 or more parameters.

trait Addable(Self, T):
    declare_fn:
        __add__(Self, T) -> Self

trait Multipliable(Self, T):
    declare_fn:
        __mul__(Self, T) -> Self


# 3. trait(type) expression is evaluated as a boolean.

StackLike(int) # -> False
StackLike(list) # -> True

Addable(str, int) # -> False
Multipliable(str, int) # -> True, since "str" * 3 is a valid expression


# 4. trait<>() expression as a semantic sugar.

Addable<int>(str) # -> False, exactly same meaning with Addable(str, int)


# 5. trait<> expression can be used like a unary trait.

def add_five(x: Addable<int>):
    return x + 5


# 6. trait extensions.

trait AddableSubable(Self, T) extends Addable(Self, T):
    declare_fn:
        __sub__(Self, T)


# 7. printinfo operator.

trait Fooable(Self):
    declare_fn:
        foo(Self, any)

printinfo Fooable

# possible output:
# """
# trait Fooable supports:
# member function .foo(any)
# """

# 8. trait and/or/not operator.

trait FooBarable(Self):
    declare_fn:
        foo(Self, any)
        bar(Self, any)

trait BarBazable(Self):
    declare_fn:
        bar(Self, any)
        baz(Self, any)

printinfo FooBarable and BarBazable

# possible output:
# """
# trait (unnamed @ line 88) supports:
# member function .foo(any)
# member function .bar(any)
# member function .baz(any)
# """

printinfo FooBarable or BarBazable

# possible output:
# """
# trait (unnamed @ line 98) supports:
# member function .bar(any)
# """




# trait_conflict 예제

trait bar(T):
    declare_fn:
        foo(Self, int) => int

trait baz(T):
    declare_fn:
        foo(Self, int) => str

trait_info(bar and baz)
# /-> declaration 중복 에러!