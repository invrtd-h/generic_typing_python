# 1. trait definition
# the following trait definition says that
# typename 'self' should support .append(x) and .pop() operation
# and __len__ method

trait StackLike(self):
    declare_fn:
        append(self, any) -> [self or None]
        pop(self) -> [self or None]

    declare_fn:
        __len__(self) -> int


# the following trait definition says that
# the instance of the class 'self' should have 'x', 'y' member variables

trait PointLike(self):
    declare:
        x: int
        y: int


# 2. traits with 2 or more parameters.

trait Addable(self, T):
    declare_fn:
        __add__(self, T) -> self

trait Multipliable(self, T):
    declare_fn:
        __mul__(self, T) -> self


# 3. trait(type) expression is evaluated as a boolean.

StackLike(int) # -> False
StackLike(list) # -> True

Addable(str, int) # -> False
Multipliable(str, int) # -> True, since "str" * 3 is a valid expression


# 4. trait<>() expression as a semantic sugar.

Addable[int](str) # -> False, exactly same meaning with Addable(str, int)


# 5. trait<> expression can be used like a unary trait.

def add_five(x: Addable[int]):
    return x + 5


# 6. trait extensions.

trait AddableSubable(self, T) extends Addable(self, T):
    declare_fn:
        __sub__(self, T)


# 7. printinfo operator.

trait Fooable(self):
    declare_fn:
        foo(self, any)

printinfo Fooable

# possible output:
# """
# trait Fooable supports:
# member function .foo(any)
# """

# 8. trait and/or/not operator.

trait FooBarable(self):
    declare_fn:
        foo(self, any)
        bar(self, any)

trait BarBazable(self):
    declare_fn:
        bar(self, any)
        baz(self, any)

printinfo FooBarable and BarBazable

# possible output:
# """
# trait (unnamed @ line 88) supports:
# member function .foo(any)
# member function .bar(any)
# member function .baz(any)
# """

printinfo FooBarable or BarBazable

# possible output:
# """
# trait (unnamed @ line 98) supports:
# member function .bar(any)
# """

# 9. typetrace operator.

def baz(x: int) -> int:
    return x + 5

typetrace(baz <| int) # -> int

# 10. overloading policies.

def try_lshift(x: any):
    return x << 2

policy Fooo:
    int -> int
    float -> float
    typename T: Addable[int] -> T
    typename U -> typetrace(try_lshift <| U)

def bazbaz(x) applies Fooo:
    if type(x) == int:
        return x
    if type(x) == float:
        return x
    if type(x) satisfies Addable[int]:
        return x + 1
    return x << 2

# 11. generate operator.

generate Fooo
generate FooBarable