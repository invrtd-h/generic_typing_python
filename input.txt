# 1. trait definition
# the following trait definition says that
# typename 'self' should support .append(x) and .pop() operation
# and __len__ method

trait any(self):
    pass

trait StackLike(self):
    fn:
        append(self, any) -> [self or None]
        pop(self) -> [self or None]
        popop(self) -> [self or (None and None)]

    fn:
        __len__(self) -> int


# the following trait definition says that
# the instance of the class 'self' should have 'x', 'y' member variables

trait PointLike(self):
    var:
        x: int
        y: int


trait AnyRandom(self):
    var:
        x: int
        y: int
        z
    fn:
        __init__(self, int, int, any) -> None
        __init__(self, int, int) -> None
        __init__(self, int) -> None
        __init__(self) -> None

    cls_fn:
        foo(cls, int) -> str
        foo(cls, float) -> str

    cls_var:
        xxx
        yyy: int

    static_fn:
        bar() -> None


t_random = any_random


trait decl_var_with_comma(self):
    var:
        [x, y, z]: int


# 2. traits with 2 or more parameters.

trait Addable(self, T):
    fn:
        __add__(self, T) -> self

trait Multipliable(self, T):
    fn:
        __mul__(self, T) -> self


# 3. trait(type) expression is evaluated as a boolean.

printinfo StackLike(int) # -> False
printinfo StackLike(list) # -> True

printinfo Addable(str, int) # -> False
printinfo Multipliable(str, int) # -> True, since "str" * 3 is a valid expression


# 4. trait[]() expression as a semantic sugar.

printinfo Addable[int](str) # -> False, exactly same meaning with Addable(str, int)


# 6. trait extensions.

trait AddableSubable(self, T) extends Addable[T]:
    fn:
        __sub__(self, T)


# 7. printinfo operator.

trait Fooable(self):
    fn:
        foo(self, any)

printinfo Fooable

# possible output:
# """
# trait Fooable supports:
# member function .foo(any)
# """

# 8. trait and/or/not operator.

trait FooBarable(self):
    fn:
        foo(self, any)
        bar(self, any)

trait BarBazable(self):
    fn:
        bar(self, any)
        baz(self, any)

printinfo [FooBarable and BarBazable]

# possible output:
# """
# trait (unnamed @ line 88) supports:
# member function .foo(any)
# member function .bar(any)
# member function .baz(any)
# """

printinfo [FooBarable or BarBazable]

# possible output:
# """
# trait (unnamed @ line 98) supports:
# member function .bar(any)
# """


printinfo typetrace(baz <| int) # -> int

# 10. overloading policies.

policy Fooo:
    int -> int
    float -> float
    typename T: Addable[int] -> T
    typename U -> typetrace(try_lshift <| U)
    default -> any


# 11. generate operator.

generate Fooo
generate FooBarable


# 12. implies operator.

printinfo [FooBarable and BarBazable] implies [FooBarable or BarBazable]

# 13. obeys operator.

trait Trait01(self):
    static_fn:
        foo() obeys Fooo

a, b = b, a

# 14. default arguments.

trait DefaultArgsExample(self, arg_a, arg_b, arg_c=int, arg_d=float):
    pass

trait TraitWithAllOptionalArgs(self, arg_a=int, arg_b=str):
    fn:
        whatever(self, int, int, =int, =int, *, a:=int, b:int)